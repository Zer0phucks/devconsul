// Prisma Schema for Full Self Publishing Platform
// Database provider: PostgreSQL (Supabase/Neon compatible)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MANAGEMENT
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  emailVerified DateTime?
  image         String?
  password      String? // For credentials auth
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // User preferences and settings
  preferences Json? // Flexible JSON for UI preferences, themes, etc.
  timezone    String  @default("UTC")
  isActive    Boolean @default(true)

  // Relationships
  accounts Account[]
  projects Project[]
  settings Settings[]
  sessions Session[]

  @@index([email])
  @@index([createdAt])
  @@map("users")
}

// NextAuth account model
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

// NextAuth session model
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

// NextAuth verification token model
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// PROJECT MANAGEMENT
// ============================================

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  userId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // GitHub Integration
  githubRepoUrl   String?
  githubRepoOwner String?
  githubRepoName  String?
  githubBranch    String?   @default("main")
  githubWebhookId String? // Store webhook ID for cleanup
  lastSyncedAt    DateTime?
  syncEnabled     Boolean   @default(false)

  // Project metadata
  status     ProjectStatus @default(ACTIVE)
  visibility Visibility    @default(PRIVATE)
  tags       String[] // Array of tags for categorization
  metadata   Json? // Flexible metadata storage

  // Relationships
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  platforms      Platform[]
  content        Content[]
  settings       Settings[]
  cronJobs       CronJob[]
  emailCampaigns EmailCampaign[]

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([githubRepoOwner, githubRepoName])
  @@map("projects")
}

enum ProjectStatus {
  ACTIVE
  PAUSED
  ARCHIVED
  DELETED
}

enum Visibility {
  PUBLIC
  PRIVATE
  UNLISTED
}

// ============================================
// PLATFORM INTEGRATIONS
// ============================================

model Platform {
  id        String       @id @default(cuid())
  projectId String
  type      PlatformType
  name      String // Custom name for this platform connection
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  // OAuth & API credentials (encrypted in production)
  accessToken    String?   @db.Text
  refreshToken   String?   @db.Text
  tokenExpiresAt DateTime?
  apiKey         String?   @db.Text
  apiSecret      String?   @db.Text

  // Platform-specific configuration
  config Json? // Platform-specific settings (RSS URL, webhook URLs, etc.)

  // Connection status
  isConnected     Boolean   @default(false)
  lastConnectedAt DateTime?
  lastErrorAt     DateTime?
  lastError       String?   @db.Text

  // Publishing stats
  totalPublished  Int       @default(0)
  lastPublishedAt DateTime?

  // Relationships
  project      Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  publications ContentPublication[]

  @@unique([projectId, type]) // One platform type per project
  @@index([projectId])
  @@index([type])
  @@index([isConnected])
  @@map("platforms")
}

enum PlatformType {
  HASHNODE
  DEVTO
  MEDIUM
  LINKEDIN
  TWITTER
  FACEBOOK
  REDDIT
  RSS_FEED
  NEWSLETTER
  RESEND
  SENDGRID
  MAILCHIMP
  WORDPRESS
  GHOST
  WEBHOOK
}

// ============================================
// CONTENT MANAGEMENT
// ============================================

model Content {
  id        String   @id @default(cuid())
  projectId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Source content (from GitHub)
  sourceType      ContentSourceType
  sourcePath      String? // GitHub file path
  sourceCommitSha String? // Git commit SHA for tracking

  // Content data
  title       String
  slug        String?
  excerpt     String? @db.Text
  body        String  @db.Text
  rawContent  String  @db.Text // Original markdown/content
  htmlContent String? @db.Text // Rendered HTML

  // Metadata
  tags         String[]
  categories   String[]
  coverImage   String?
  canonicalUrl String?

  // Content status
  status       ContentStatus @default(DRAFT)
  publishedAt  DateTime?
  scheduledFor DateTime?

  // AI generation metadata
  isAIGenerated Boolean @default(false)
  aiModel       String?
  aiPrompt      String? @db.Text
  aiMetadata    Json?

  // Version control
  version  Int       @default(1)
  parentId String? // For content versions
  parent   Content?  @relation("ContentVersions", fields: [parentId], references: [id])
  versions Content[] @relation("ContentVersions")

  // Relationships
  project      Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  publications ContentPublication[]
  contentImages ContentImage[]
  scheduledContent ScheduledContent[]

  @@index([projectId])
  @@index([status])
  @@index([publishedAt])
  @@index([scheduledFor])
  @@index([sourceCommitSha])
  @@index([createdAt])
  @@map("content")
}

enum ContentSourceType {
  GITHUB_MARKDOWN
  GITHUB_MDX
  AI_GENERATED
  MANUAL
  IMPORT
}

enum ContentStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  FAILED
  ARCHIVED
}

// Content publication tracking (many-to-many with platforms)
model ContentPublication {
  id         String   @id @default(cuid())
  contentId  String
  platformId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Publication details
  publishedAt    DateTime?
  platformPostId String? // ID from the platform (e.g., Hashnode post ID)
  platformUrl    String? // Direct URL to published content

  // Status
  status        PublicationStatus @default(PENDING)
  error         String?           @db.Text
  retryCount    Int               @default(0)
  lastAttemptAt DateTime?

  // Platform-specific metadata
  platformMetadata Json?

  // Relationships
  content  Content  @relation(fields: [contentId], references: [id], onDelete: Cascade)
  platform Platform @relation(fields: [platformId], references: [id], onDelete: Cascade)

  @@unique([contentId, platformId])
  @@index([contentId])
  @@index([platformId])
  @@index([status])
  @@index([publishedAt])
  @@map("content_publications")
}

enum PublicationStatus {
  PENDING
  PUBLISHING
  PUBLISHED
  FAILED
  RETRYING
}

// ============================================
// SETTINGS & CONFIGURATION
// ============================================

model Settings {
  id        String   @id @default(cuid())
  userId    String
  projectId String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Settings scope
  scope SettingsScope @default(PROJECT)

  // Content generation settings
  contentPreferences Json? // AI model, tone, style, length preferences

  // Publishing automation
  autoPublish    Boolean @default(false)
  publishDelay   Int? // Minutes to wait before auto-publishing
  contentFilters Json? // Filters for which content to publish

  // Scheduling settings
  cronFrequency      String? // Cron expression for content checks
  timezone           String  @default("UTC")
  publishingSchedule Json? // Preferred publishing times

  // Notification settings
  emailNotifications Boolean  @default(true)
  webhookUrl         String?
  notificationEvents String[] // Array of events to notify about

  // Advanced settings
  customSettings Json? // Flexible key-value storage

  // Relationships
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([userId, projectId, scope])
  @@index([userId])
  @@index([projectId])
  @@map("settings")
}

enum SettingsScope {
  USER
  PROJECT
  PLATFORM
}

// ============================================
// CRON JOBS & AUTOMATION
// ============================================

model CronJob {
  id        String   @id @default(cuid())
  projectId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Job configuration
  name        String
  description String?     @db.Text
  type        CronJobType
  schedule    String // Cron expression
  timezone    String      @default("UTC")

  // Job status
  isEnabled Boolean       @default(true)
  status    CronJobStatus @default(IDLE)

  // Execution tracking
  lastRunAt    DateTime?
  lastSuccess  DateTime?
  lastFailure  DateTime?
  nextRunAt    DateTime?
  runCount     Int       @default(0)
  successCount Int       @default(0)
  failureCount Int       @default(0)

  // Error handling
  maxRetries Int @default(3)
  retryDelay Int @default(300) // Seconds

  // Job configuration
  config Json? // Job-specific configuration

  // Relationships
  project    Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  executions CronExecution[]

  @@index([projectId])
  @@index([isEnabled])
  @@index([status])
  @@index([nextRunAt])
  @@index([type])
  @@map("cron_jobs")
}

enum CronJobType {
  SYNC_GITHUB // Sync content from GitHub
  PUBLISH_CONTENT // Auto-publish scheduled content
  GENERATE_CONTENT // AI content generation
  CLEANUP // Database cleanup
  ANALYTICS // Generate analytics
  CUSTOM // User-defined job
}

enum CronJobStatus {
  IDLE
  RUNNING
  COMPLETED
  FAILED
  DISABLED
}

// Cron job execution logs
model CronExecution {
  id        String   @id @default(cuid())
  jobId     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Execution details
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  duration    Int? // Milliseconds

  // Status
  status     ExecutionStatus @default(RUNNING)
  error      String?         @db.Text
  stackTrace String?         @db.Text

  // Execution metadata
  triggeredBy String? // manual, scheduled, webhook
  metadata    Json?

  // Execution results
  itemsProcessed Int?
  itemsSuccess   Int?
  itemsFailed    Int?
  output         Json? // Execution output/results

  // Relationships
  job CronJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([status])
  @@index([startedAt])
  @@index([createdAt])
  @@map("cron_executions")
}

enum ExecutionStatus {
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  TIMEOUT
}

// ============================================
// AUDIT & ANALYTICS
// ============================================

model AuditLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Actor information
  userId    String?
  userEmail String?
  ipAddress String?
  userAgent String? @db.Text

  // Action details
  action     String // create, update, delete, publish, etc.
  resource   AuditResource
  resourceId String

  // Changes
  oldValues Json?
  newValues Json?
  metadata  Json?

  // Context
  projectId  String?
  platformId String?

  @@index([userId])
  @@index([resource, resourceId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

enum AuditResource {
  USER
  PROJECT
  PLATFORM
  CONTENT
  SETTINGS
  CRON_JOB
  EMAIL_CAMPAIGN
}

// ============================================
// EMAIL PLATFORMS & CAMPAIGNS
// ============================================

model EmailCampaign {
  id        String   @id @default(cuid())
  projectId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Campaign details
  name      String
  subject   String
  fromEmail String
  fromName  String?
  replyTo   String?

  // Content
  templateId  String? // Reference to email template
  htmlContent String  @db.Text
  textContent String? @db.Text

  // Campaign metadata
  tags     String[]
  metadata Json?

  // Status
  status      EmailCampaignStatus @default(DRAFT)
  scheduledAt DateTime?
  sentAt      DateTime?

  // Stats
  totalRecipients   Int @default(0)
  totalSent         Int @default(0)
  totalDelivered    Int @default(0)
  totalOpened       Int @default(0)
  totalClicked      Int @default(0)
  totalBounced      Int @default(0)
  totalUnsubscribed Int @default(0)

  // Platform (which email service to use)
  emailProvider EmailProvider @default(RESEND)
  platformId    String? // Reference to Platform if using platform config

  // Relationships
  project    Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  recipients EmailRecipient[]
  emailImages EmailImage[]

  @@index([projectId])
  @@index([status])
  @@index([scheduledAt])
  @@index([sentAt])
  @@index([emailProvider])
  @@map("email_campaigns")
}

enum EmailCampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  PAUSED
  CANCELLED
  FAILED
}

enum EmailProvider {
  RESEND
  SENDGRID
  MAILCHIMP
}

model EmailRecipient {
  id         String   @id @default(cuid())
  campaignId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Recipient details
  email        String
  name         String?
  customFields Json? // Additional merge fields

  // Tracking token (for unsubscribe, opens, clicks)
  token String @unique @default(cuid())

  // Status
  status         EmailRecipientStatus @default(PENDING)
  sentAt         DateTime?
  deliveredAt    DateTime?
  openedAt       DateTime?
  clickedAt      DateTime?
  bouncedAt      DateTime?
  unsubscribedAt DateTime?

  // Tracking
  openCount  Int @default(0)
  clickCount Int @default(0)

  // Bounce/error info
  bounceType String? // hard, soft, spam
  errorMsg   String? @db.Text

  // Relationships
  campaign EmailCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@index([campaignId])
  @@index([email])
  @@index([token])
  @@index([status])
  @@map("email_recipients")
}

enum EmailRecipientStatus {
  PENDING
  SENT
  DELIVERED
  OPENED
  CLICKED
  BOUNCED
  FAILED
  UNSUBSCRIBED
}

// Global unsubscribe list (cross-project)
model EmailUnsubscribe {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  email          String   @unique
  unsubscribedAt DateTime @default(now())

  // Reason
  reason String? @db.Text

  // Source (which campaign/project they unsubscribed from)
  projectId  String?
  campaignId String?

  // Token used to unsubscribe
  token String?

  // User can re-subscribe
  isActive       Boolean   @default(true)
  resubscribedAt DateTime?

  @@index([email])
  @@index([isActive])
  @@index([projectId])
  @@map("email_unsubscribes")
}

// Email templates
model EmailTemplate {
  id        String   @id @default(cuid())
  projectId String? // null = global template
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Template details
  name        String
  description String? @db.Text
  subject     String? // Default subject

  // Content
  htmlContent String  @db.Text
  textContent String? @db.Text

  // Template type
  type EmailTemplateType @default(CUSTOM)

  // Variables/merge tags this template uses
  variables String[] // e.g., ["name", "content", "unsubscribe"]

  // Template metadata
  category String?
  tags     String[]
  isPublic Boolean  @default(false)

  @@index([projectId])
  @@index([type])
  @@index([isPublic])
  @@map("email_templates")
}

enum EmailTemplateType {
  NEWSLETTER
  ANNOUNCEMENT
  DIGEST
  PLAIN
  CUSTOM
}

// ============================================
// CONTENT TEMPLATES & CUSTOMIZATION
// ============================================

// Universal content templates for all platforms
model Template {
  id        String   @id @default(cuid())
  projectId String? // null = global/default template
  userId    String? // Template creator
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Template details
  name        String
  description String? @db.Text
  platform    TemplatePlatform
  category    String? // e.g., "technical", "announcement", "tutorial"

  // Template content with variable placeholders
  content     String  @db.Text // Template body with {{variables}}
  subject     String? // For email/newsletter templates

  // Template metadata
  variables   String[] // List of available variables: ["repository", "activity", "date"]
  tags        String[]
  isDefault   Boolean  @default(false) // System default template
  isPublic    Boolean  @default(false) // Shareable template

  // Version control
  version     Int      @default(1)
  parentId    String? // For template versions
  parent      Template?  @relation("TemplateVersions", fields: [parentId], references: [id])
  versions    Template[] @relation("TemplateVersions")

  // Usage analytics
  usageCount     Int      @default(0)
  lastUsedAt     DateTime?
  effectivenessScore Float? // A/B testing score

  // Relationships
  promptLibrary PromptLibrary[]
  contentHistory ContentTemplateHistory[]

  @@index([projectId])
  @@index([userId])
  @@index([platform])
  @@index([category])
  @@index([isDefault])
  @@index([isPublic])
  @@index([usageCount])
  @@map("templates")
}

enum TemplatePlatform {
  BLOG
  EMAIL
  NEWSLETTER
  TWITTER
  LINKEDIN
  FACEBOOK
  REDDIT
  HASHNODE
  DEVTO
  MEDIUM
  WORDPRESS
  GHOST
  ALL // Universal template
}

// AI Prompt library for content generation
model PromptLibrary {
  id        String   @id @default(cuid())
  projectId String? // null = global/shared prompt
  userId    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Prompt details
  name        String
  description String? @db.Text
  category    PromptCategory

  // Prompt content
  systemPrompt String  @db.Text // System instructions for AI
  userPrompt   String  @db.Text // User prompt template with {{variables}}

  // Associated template (optional)
  templateId  String?
  template    Template? @relation(fields: [templateId], references: [id])

  // Prompt configuration
  variables     String[] // Variables used in prompts
  platform      TemplatePlatform
  contentType   String? // "technical", "marketing", "educational"
  tone          String? // "professional", "casual", "friendly"
  targetLength  Int? // Target word/character count

  // Metadata
  tags          String[]
  isDefault     Boolean @default(false)
  isPublic      Boolean @default(false)

  // Version control
  version       Int     @default(1)
  parentId      String?
  parent        PromptLibrary?  @relation("PromptVersions", fields: [parentId], references: [id])
  versions      PromptLibrary[] @relation("PromptVersions")

  // Effectiveness tracking
  usageCount           Int      @default(0)
  lastUsedAt           DateTime?
  averageRating        Float?
  successRate          Float? // % of successful generations
  averageTokenUsage    Int?

  @@index([projectId])
  @@index([userId])
  @@index([category])
  @@index([platform])
  @@index([isDefault])
  @@index([isPublic])
  @@index([templateId])
  @@map("prompt_library")
}

enum PromptCategory {
  TECHNICAL_UPDATE
  FEATURE_ANNOUNCEMENT
  BUG_FIX
  RELEASE_NOTES
  TUTORIAL
  CASE_STUDY
  WEEKLY_DIGEST
  MONTHLY_SUMMARY
  PRODUCT_UPDATE
  COMMUNITY_UPDATE
  CUSTOM
}

// Track content generation history with templates
model ContentTemplateHistory {
  id        String   @id @default(cuid())
  contentId String
  createdAt DateTime @default(now())

  // Template used
  templateId String?
  template   Template? @relation(fields: [templateId], references: [id])

  // Prompt used
  promptId   String?

  // Generation metadata
  variables  Json // Variables substituted: {repository: "...", activity: "..."}
  platform   TemplatePlatform

  // Performance tracking
  generatedContent String  @db.Text
  wasEdited        Boolean @default(false)
  editDistance     Int? // How much was changed from template
  timeToEdit       Int? // Seconds spent editing

  // Effectiveness metrics
  wasPublished     Boolean   @default(false)
  publishedAt      DateTime?
  engagementScore  Float? // Clicks, opens, shares, etc.
  userRating       Int? // 1-5 stars

  @@index([templateId])
  @@index([contentId])
  @@index([platform])
  @@index([createdAt])
  @@map("content_template_history")
}

// ============================================
// IMAGE MANAGEMENT
// ============================================

model Image {
  id        String   @id @default(cuid())
  userId    String
  projectId String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Image metadata
  filename     String
  originalName String
  mimeType     String
  size         Int // File size in bytes
  width        Int
  height       Int
  aspectRatio  Float

  // Storage
  storageUrl    String // URL to stored image (Vercel Blob/R2)
  storagePath   String // Storage path/key
  storageProvider String @default("vercel-blob") // vercel-blob, cloudflare-r2, s3

  // Image data
  alt           String? @db.Text
  caption       String? @db.Text
  title         String?
  description   String? @db.Text

  // Categorization
  tags       String[]
  categories String[]

  // Generation metadata
  isAIGenerated  Boolean  @default(false)
  aiModel        String? // dall-e-3, stable-diffusion
  aiPrompt       String?  @db.Text
  aiRevisedPrompt String? @db.Text // DALL-E revised prompt
  aiQuality      String? // standard, hd
  aiStyle        String? // vivid, natural
  generatedAt    DateTime?

  // Platform-specific versions
  platformVersions Json? // Store different sizes/formats per platform

  // Usage tracking
  usageCount    Int      @default(0)
  lastUsedAt    DateTime?

  // Optimization
  isOptimized   Boolean @default(false)
  originalSize  Int? // Original file size before optimization
  optimizedAt   DateTime?

  // Relations
  contentImages ContentImage[]
  emailImages   EmailImage[]

  @@index([userId])
  @@index([projectId])
  @@index([isAIGenerated])
  @@index([createdAt])
  @@index([tags])
  @@map("images")
}

// Junction table for Content-Image relationship
model ContentImage {
  id        String   @id @default(cuid())
  contentId String
  imageId   String
  createdAt DateTime @default(now())

  // Image role in content
  role ImageRole @default(INLINE)

  // Platform-specific metadata
  platformType PlatformType?
  platformUrl  String? // Platform-specific image URL after upload

  // Position and settings
  position Int? // Order in content
  settings Json? // Platform-specific image settings

  // Relations
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)
  image   Image   @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([contentId, imageId, role])
  @@index([contentId])
  @@index([imageId])
  @@index([platformType])
  @@map("content_images")
}

enum ImageRole {
  FEATURED // Featured/cover image
  HERO // Hero image
  INLINE // Inline content image
  THUMBNAIL // Thumbnail
  OG_IMAGE // Open Graph image
  TWITTER_CARD // Twitter card image
  EMAIL_HEADER // Email header image
  BANNER // Banner image
}

// Junction table for EmailCampaign-Image relationship
model EmailImage {
  id         String   @id @default(cuid())
  campaignId String
  imageId    String
  createdAt  DateTime @default(now())

  // Image role in email
  role ImageRole @default(EMAIL_HEADER)

  // Position and settings
  position Int?
  settings Json?

  // Relations
  campaign EmailCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  image    Image         @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([campaignId, imageId, role])
  @@index([campaignId])
  @@index([imageId])
  @@map("email_images")
}

// Image generation jobs (for tracking batch generation)
model ImageGenerationJob {
  id        String   @id @default(cuid())
  userId    String
  projectId String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Job details
  name        String?
  description String? @db.Text

  // Generation parameters
  prompts      String[] // Array of prompts to generate
  model        String   @default("dall-e-3")
  quality      String   @default("standard") // standard, hd
  style        String   @default("vivid") // vivid, natural
  size         String   @default("1024x1024") // 1024x1024, 1792x1024, 1024x1792

  // Job status
  status         ImageJobStatus @default(PENDING)
  totalImages    Int            @default(0)
  generatedCount Int            @default(0)
  failedCount    Int            @default(0)

  // Cost tracking
  totalCost Float @default(0)

  // Completion tracking
  startedAt   DateTime?
  completedAt DateTime?

  // Error handling
  errors Json? // Array of error objects

  // Results
  imageIds String[] // Array of generated image IDs

  @@index([userId])
  @@index([projectId])
  @@index([status])
  @@index([createdAt])
  @@map("image_generation_jobs")
}

enum ImageJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

// ============================================
// SCHEDULING & QUEUE SYSTEM
// ============================================

// Scheduled content for future publishing
model ScheduledContent {
  id        String   @id @default(cuid())
  contentId String
  projectId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Schedule configuration
  scheduledFor DateTime // When to publish (UTC)
  timezone     String   @default("UTC") // IANA timezone for display
  localTime    String? // Human-readable local time (e.g., "2025-01-15 09:00 AM PST")

  // Recurring schedule (optional)
  isRecurring      Boolean  @default(false)
  recurringPattern String? // cron-like pattern or "daily|weekly|monthly"
  recurringConfig  Json? // Additional recurrence config (days of week, etc.)
  recurringUntil   DateTime? // End date for recurring schedule
  lastOccurrence   DateTime? // Track last execution for recurring jobs

  // Publishing configuration
  platforms    String[] // Platform IDs to publish to
  publishDelay Int?     @default(0) // Additional delay in minutes after scheduled time

  // Queue information
  queueStatus  QueueStatus @default(PENDING)
  queuedAt     DateTime? // When added to queue
  processingAt DateTime? // When started processing
  publishedAt  DateTime? // When actually published
  failedAt     DateTime? // When failed

  // Priority and retry
  priority   Int     @default(5) // 1-10, higher = more priority
  retryCount Int     @default(0)
  maxRetries Int     @default(3)
  retryDelay Int     @default(300) // Seconds between retries

  // Status and error tracking
  status       ScheduleStatus @default(SCHEDULED)
  error        String?        @db.Text
  errorDetails Json? // Detailed error information

  // Conflict detection
  conflictsWith String[] // IDs of conflicting schedules
  conflictNote  String?  @db.Text

  // Inngest job tracking
  inngestJobId  String? // Inngest scheduled function run ID
  inngestEventId String? // Inngest event ID

  // Metadata
  metadata Json? // Additional scheduling metadata
  notes    String? @db.Text // User notes about this schedule

  // Relationships
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@index([contentId])
  @@index([projectId])
  @@index([scheduledFor])
  @@index([queueStatus])
  @@index([status])
  @@index([priority])
  @@index([timezone])
  @@index([isRecurring])
  @@map("scheduled_content")
}

enum QueueStatus {
  PENDING // Waiting in queue
  QUEUED // Ready for processing
  PROCESSING // Currently being processed
  COMPLETED // Successfully completed
  FAILED // Failed after all retries
  CANCELLED // Manually cancelled
  PAUSED // Temporarily paused
}

enum ScheduleStatus {
  SCHEDULED // Waiting for scheduled time
  ACTIVE // Currently being executed
  PUBLISHED // Successfully published
  FAILED // Failed to publish
  CANCELLED // User cancelled
  EXPIRED // Passed scheduled time without execution
  SKIPPED // Skipped due to conflict or other reason
}

// Queue tracking and analytics
model QueueMetrics {
  id        String   @id @default(cuid())
  projectId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Time period
  periodStart DateTime
  periodEnd   DateTime

  // Throughput metrics
  totalQueued     Int @default(0)
  totalProcessed  Int @default(0)
  totalCompleted  Int @default(0)
  totalFailed     Int @default(0)
  totalCancelled  Int @default(0)

  // Performance metrics
  avgWaitTime       Int? // Average time in queue (seconds)
  avgProcessingTime Int? // Average processing time (seconds)
  peakQueueLength   Int  @default(0)

  // Success rate
  successRate Float? // Percentage of successful completions

  // Platform breakdown
  platformStats Json? // Stats per platform

  @@index([projectId])
  @@index([periodStart])
  @@index([periodEnd])
  @@map("queue_metrics")
}

// Schedule conflicts tracking
model ScheduleConflict {
  id        String   @id @default(cuid())
  projectId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Conflicting schedules
  schedule1Id String
  schedule2Id String

  // Conflict details
  conflictType   ConflictType
  conflictTime   DateTime // When the conflict occurs
  conflictReason String       @db.Text

  // Resolution
  resolved      Boolean   @default(false)
  resolvedAt    DateTime?
  resolution    String?   @db.Text // How it was resolved
  resolvedBy    String? // User ID who resolved it

  // Severity
  severity ConflictSeverity @default(WARNING)

  @@index([projectId])
  @@index([schedule1Id])
  @@index([schedule2Id])
  @@index([conflictTime])
  @@index([resolved])
  @@map("schedule_conflicts")
}

enum ConflictType {
  SAME_TIME // Both scheduled for exact same time
  OVERLAPPING // Time ranges overlap
  RATE_LIMIT // Would exceed platform rate limits
  RESOURCE // Would exceed resource limits
  CUSTOM // Custom conflict rule
}

enum ConflictSeverity {
  INFO // Just for information
  WARNING // Potential issue, can proceed
  ERROR // Must be resolved before proceeding
  CRITICAL // Blocking issue
}
