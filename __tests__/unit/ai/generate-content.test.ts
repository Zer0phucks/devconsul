/**
 * Unit tests for Generate Content Helper (Multi-platform)
 */

import {
  generateContent,
  refineContent,
  type GenerateContentOptions,
} from '@/lib/ai/generate-content';

// Mock AI SDK
jest.mock('ai', () => ({
  generateText: jest.fn(),
}));

jest.mock('@ai-sdk/openai', () => ({
  openai: jest.fn((model) => `openai:${model}`),
}));

jest.mock('@ai-sdk/anthropic', () => ({
  anthropic: jest.fn((model) => `anthropic:${model}`),
}));

import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';
import { anthropic } from '@ai-sdk/anthropic';

const mockGenerateText = generateText as jest.MockedFunction<typeof generateText>;
const mockOpenAI = openai as jest.MockedFunction<typeof openai>;
const mockAnthropic = anthropic as jest.MockedFunction<typeof anthropic>;

describe('Generate Content (Multi-platform)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('generateContent()', () => {
    it('should generate content for Twitter platform with GPT-4', async () => {
      mockGenerateText.mockResolvedValue({
        text: '1/ This week we launched authentication ðŸŽ‰\n\n2/ Key features include OAuth2 and JWT tokens\n\n3/ Check it out at example.com #webdev',
      });

      const result = await generateContent(
        'Create a thread about our auth launch',
        'twitter',
        'gpt-4'
      );

      expect(result).toEqual({
        content: expect.stringContaining('authentication'),
        cost: 0.003,
        model: 'gpt-4',
      });

      expect(mockOpenAI).toHaveBeenCalledWith('gpt-4');
      expect(mockGenerateText).toHaveBeenCalledWith(
        expect.objectContaining({
          model: 'openai:gpt-4',
          system: expect.stringContaining('twitter'),
          maxTokens: 2000,
        })
      );
    });

    it('should generate content for LinkedIn with GPT-3.5', async () => {
      mockGenerateText.mockResolvedValue({
        text: 'Professional post about authentication improvements...',
      });

      const result = await generateContent(
        'Create a LinkedIn post',
        'linkedin',
        'gpt-3.5-turbo'
      );

      expect(result).toEqual({
        content: expect.any(String),
        cost: 0.001,
        model: 'gpt-3.5-turbo',
      });

      expect(mockOpenAI).toHaveBeenCalledWith('gpt-3.5-turbo');
    });

    it('should generate content with Claude Sonnet', async () => {
      mockGenerateText.mockResolvedValue({
        text: 'Blog post content generated by Claude...',
      });

      const result = await generateContent(
        'Write a blog post',
        'blog',
        'claude-3-sonnet'
      );

      expect(result).toEqual({
        content: expect.any(String),
        cost: 0.003,
        model: 'claude-3-sonnet',
      });

      expect(mockAnthropic).toHaveBeenCalledWith('claude-3-sonnet-20240229');
    });

    it('should default to GPT-4 when no model specified', async () => {
      mockGenerateText.mockResolvedValue({
        text: 'Default content',
      });

      const result = await generateContent(
        'Generate content',
        'general'
      );

      expect(result.model).toBe('gpt-4');
      expect(mockOpenAI).toHaveBeenCalledWith('gpt-4');
    });

    it('should include platform in system prompt', async () => {
      mockGenerateText.mockResolvedValue({ text: 'Content' });

      await generateContent('Prompt', 'Medium', 'gpt-4');

      expect(mockGenerateText).toHaveBeenCalledWith(
        expect.objectContaining({
          system: expect.stringContaining('Medium platform'),
        })
      );
    });

    it('should pass maxTokens parameter', async () => {
      mockGenerateText.mockResolvedValue({ text: 'Content' });

      await generateContent('Prompt', 'twitter', 'gpt-4');

      expect(mockGenerateText).toHaveBeenCalledWith(
        expect.objectContaining({
          maxTokens: 2000,
        })
      );
    });

    it('should handle generation errors', async () => {
      mockGenerateText.mockRejectedValue(new Error('API Error'));

      await expect(
        generateContent('Prompt', 'twitter', 'gpt-4')
      ).rejects.toThrow('Failed to generate content with AI');
    });

    it('should calculate different costs for different models', async () => {
      mockGenerateText.mockResolvedValue({ text: 'Content' });

      const gpt4Result = await generateContent('Prompt', 'blog', 'gpt-4');
      expect(gpt4Result.cost).toBe(0.003);

      const gpt35Result = await generateContent('Prompt', 'blog', 'gpt-3.5-turbo');
      expect(gpt35Result.cost).toBe(0.001);

      const claudeResult = await generateContent('Prompt', 'blog', 'claude-3-sonnet');
      expect(claudeResult.cost).toBe(0.003);
    });
  });

  describe('Platform-Specific Content Generation', () => {
    beforeEach(() => {
      mockGenerateText.mockResolvedValue({ text: 'Generated content' });
    });

    it('should generate Twitter thread with character limits', async () => {
      await generateContent(
        'Create thread about new features',
        'twitter',
        'gpt-4'
      );

      const call = mockGenerateText.mock.calls[0][0];
      expect(call.system).toContain('twitter');
    });

    it('should generate LinkedIn post', async () => {
      await generateContent(
        'Professional announcement',
        'linkedin',
        'gpt-4'
      );

      const call = mockGenerateText.mock.calls[0][0];
      expect(call.system).toContain('linkedin');
    });

    it('should generate blog post', async () => {
      await generateContent(
        'Technical article',
        'blog',
        'gpt-4'
      );

      const call = mockGenerateText.mock.calls[0][0];
      expect(call.system).toContain('blog');
    });

    it('should generate Medium article', async () => {
      await generateContent(
        'Story about development',
        'Medium',
        'gpt-4'
      );

      const call = mockGenerateText.mock.calls[0][0];
      expect(call.system).toContain('Medium');
    });

    it('should generate Dev.to post', async () => {
      await generateContent(
        'Tutorial article',
        'dev.to',
        'gpt-4'
      );

      const call = mockGenerateText.mock.calls[0][0];
      expect(call.system).toContain('dev.to');
    });

    it('should generate Hashnode article', async () => {
      await generateContent(
        'Technical deep dive',
        'hashnode',
        'gpt-4'
      );

      const call = mockGenerateText.mock.calls[0][0];
      expect(call.system).toContain('hashnode');
    });
  });

  describe('refineContent()', () => {
    it('should refine existing content', async () => {
      mockGenerateText.mockResolvedValue({
        text: 'Refined and improved content',
      });

      const result = await refineContent(
        'Original content to improve',
        'Make it more engaging',
        'gpt-4'
      );

      expect(result).toEqual({
        content: 'Refined and improved content',
        cost: 0.003,
        model: 'gpt-4',
      });
    });

    it('should include original content in refinement prompt', async () => {
      mockGenerateText.mockResolvedValue({ text: 'Refined' });

      await refineContent(
        'Original blog post content',
        'Add more examples',
        'gpt-4'
      );

      const call = mockGenerateText.mock.calls[0][0];
      expect(call.prompt).toContain('Original content:');
      expect(call.prompt).toContain('Original blog post content');
      expect(call.prompt).toContain('Refinement instructions: Add more examples');
    });

    it('should include refinement instructions', async () => {
      mockGenerateText.mockResolvedValue({ text: 'Refined' });

      await refineContent(
        'Content',
        'Improve tone and clarity',
        'gpt-4'
      );

      const call = mockGenerateText.mock.calls[0][0];
      expect(call.prompt).toContain('Improve tone and clarity');
    });

    it('should default to GPT-4 for refinement', async () => {
      mockGenerateText.mockResolvedValue({ text: 'Refined' });

      const result = await refineContent('Content', 'Improve it');

      expect(result.model).toBe('gpt-4');
    });

    it('should support Claude for refinement', async () => {
      mockGenerateText.mockResolvedValue({ text: 'Refined' });

      const result = await refineContent(
        'Content',
        'Improve it',
        'claude-3-sonnet'
      );

      expect(result.model).toBe('claude-3-sonnet');
      expect(mockAnthropic).toHaveBeenCalledWith('claude-3-sonnet-20240229');
    });

    it('should handle refinement errors', async () => {
      mockGenerateText.mockRejectedValue(new Error('Refinement failed'));

      await expect(
        refineContent('Content', 'Improve it', 'gpt-4')
      ).rejects.toThrow('Failed to generate content with AI');
    });
  });

  describe('Model Selection Logic', () => {
    beforeEach(() => {
      mockGenerateText.mockResolvedValue({ text: 'Content' });
    });

    it('should use GPT-3.5-turbo correctly', async () => {
      await generateContent('Prompt', 'twitter', 'gpt-3.5-turbo');

      expect(mockOpenAI).toHaveBeenCalledWith('gpt-3.5-turbo');
      expect(mockAnthropic).not.toHaveBeenCalled();
    });

    it('should use GPT-4 correctly', async () => {
      await generateContent('Prompt', 'blog', 'gpt-4');

      expect(mockOpenAI).toHaveBeenCalledWith('gpt-4');
      expect(mockAnthropic).not.toHaveBeenCalled();
    });

    it('should use Claude correctly', async () => {
      await generateContent('Prompt', 'blog', 'claude-3-sonnet');

      expect(mockAnthropic).toHaveBeenCalledWith('claude-3-sonnet-20240229');
      expect(mockOpenAI).not.toHaveBeenCalled();
    });

    it('should fallback to GPT-4 for unknown model', async () => {
      // @ts-expect-error Testing invalid model
      await generateContent('Prompt', 'blog', 'invalid-model');

      expect(mockOpenAI).toHaveBeenCalledWith('gpt-4');
    });
  });

  describe('Cost Estimation', () => {
    beforeEach(() => {
      mockGenerateText.mockResolvedValue({ text: 'Content' });
    });

    it('should estimate GPT-3.5-turbo cost', async () => {
      const result = await generateContent('Prompt', 'blog', 'gpt-3.5-turbo');
      expect(result.cost).toBe(0.001);
    });

    it('should estimate GPT-4 cost', async () => {
      const result = await generateContent('Prompt', 'blog', 'gpt-4');
      expect(result.cost).toBe(0.003);
    });

    it('should estimate Claude cost', async () => {
      const result = await generateContent('Prompt', 'blog', 'claude-3-sonnet');
      expect(result.cost).toBe(0.003);
    });
  });

  describe('Error Handling', () => {
    it('should log errors before throwing', async () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
      mockGenerateText.mockRejectedValue(new Error('Test error'));

      await expect(
        generateContent('Prompt', 'twitter', 'gpt-4')
      ).rejects.toThrow();

      expect(consoleSpy).toHaveBeenCalledWith(
        'Failed to generate content:',
        expect.any(Error)
      );

      consoleSpy.mockRestore();
    });

    it('should handle network errors', async () => {
      const networkError = new Error('Network timeout');
      mockGenerateText.mockRejectedValue(networkError);

      await expect(
        generateContent('Prompt', 'blog', 'gpt-4')
      ).rejects.toThrow('Failed to generate content with AI');
    });

    it('should handle API errors', async () => {
      const apiError = new Error('API rate limit');
      mockGenerateText.mockRejectedValue(apiError);

      await expect(
        generateContent('Prompt', 'blog', 'gpt-4')
      ).rejects.toThrow('Failed to generate content with AI');
    });
  });
});
