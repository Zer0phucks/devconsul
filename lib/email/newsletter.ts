import { Resend } from 'resend';
import { prisma } from '@/lib/db';
import { kv } from '@/lib/supabase/kv';
import { generateNewsletter } from '@/lib/ai/content-generator';
import { getRecentActivities } from '@/lib/github/webhook-handler';
import type { Newsletter, Subscriber, GitHubActivity } from '@/lib/types';
import NewsletterEmail from '@/emails/newsletter-template';

const resend = new Resend(process.env.RESEND_API_KEY);

// Generate and send weekly newsletter
export async function generateAndSendNewsletter(): Promise<void> {
  try {
    console.log('Starting newsletter generation...');

    // Get activities from the past week
    const activities = await getWeeklyActivities();

    if (activities.length === 0) {
      console.log('No activities this week, skipping newsletter');
      return;
    }

    // Generate newsletter content
    const content = await generateNewsletter(activities);

    // Parse content into newsletter format
    const newsletterContent = parseNewsletterContent(content.content);

    // Get active subscribers
    const subscribers = await getActiveSubscribers();

    if (subscribers.length === 0) {
      console.log('No active subscribers');
      return;
    }

    // Create newsletter record
    const newsletter = await createNewsletterRecord({
      subject: content.title,
      content: content.content,
      htmlContent: '', // Will be generated by React Email
      status: 'scheduled',
      activities,
    });

    // Send to all subscribers
    await sendNewsletterToSubscribers(newsletter, subscribers, newsletterContent);

    // Update newsletter status
    await updateNewsletterStatus(newsletter.id, 'sent', subscribers.length);

    console.log(`Newsletter sent to ${subscribers.length} subscribers`);
  } catch (error) {
    console.error('Failed to generate and send newsletter:', error);
    throw error;
  }
}

// Get activities from the past week
async function getWeeklyActivities(): Promise<GitHubActivity[]> {
  const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;

  // Get all recent activities
  const activities = await getRecentActivities(100);

  // Filter to past week only
  return activities.filter(activity =>
    new Date(activity.timestamp).getTime() > oneWeekAgo
  );
}

// Parse newsletter content into structured format
function parseNewsletterContent(content: string): {
  highlights: string[];
  details: string;
  whatsNext: string;
} {
  // Simple parsing - in production, use more sophisticated parsing
  const sections = content.split(/##\s+/);

  const highlights: string[] = [];
  let details = '';
  let whatsNext = '';

  sections.forEach(section => {
    if (section.toLowerCase().includes('highlight')) {
      // Extract bullet points
      const bullets = section.match(/[-*]\s+(.+)/g) || [];
      highlights.push(...bullets.map(b => b.replace(/[-*]\s+/, '')));
    } else if (section.toLowerCase().includes('detail')) {
      details = section.replace(/.*\n/, '').trim();
    } else if (section.toLowerCase().includes('next')) {
      whatsNext = section.replace(/.*\n/, '').trim();
    }
  });

  // Fallback if parsing fails
  if (highlights.length === 0) {
    highlights.push('Weekly development updates');
  }
  if (!details) {
    details = content.substring(0, 500);
  }
  if (!whatsNext) {
    whatsNext = 'More updates coming next week!';
  }

  return { highlights, details, whatsNext };
}

// Get active subscribers
async function getActiveSubscribers(): Promise<Subscriber[]> {
  try {
    const unsubscribes = await prisma.emailUnsubscribe.findMany({
      select: { email: true },
    });

    const unsubscribedEmails = unsubscribes.map((u) => u.email);

    // Get recipients who haven't unsubscribed
    // Note: EmailRecipient doesn't have frequency, so we get all active ones
    const recipients = await prisma.emailRecipient.findMany({
      where: {
        email: {
          notIn: unsubscribedEmails,
        },
        status: 'DELIVERED', // Assuming active means previously delivered
      },
      distinct: ['email'],
      select: {
        email: true,
        metadata: true,
      },
    });

    // Transform to Subscriber format
    return recipients.map((r) => {
      const metadata = (r.metadata as any) || {};
      return {
        id: r.email, // Using email as ID
        email: r.email,
        name: metadata.name,
        subscribedAt: metadata.subscribedAt ? new Date(metadata.subscribedAt) : new Date(),
        status: 'active' as const,
        preferences: {
          frequency: 'weekly' as const,
          topics: metadata.topics || [],
        },
      };
    });
  } catch (error) {
    console.error('Failed to get subscribers:', error);
    return [];
  }
}

// Create newsletter record
async function createNewsletterRecord(
  data: Omit<Newsletter, 'id' | 'sentAt' | 'recipientCount' | 'openRate' | 'clickRate'>
): Promise<Newsletter> {
  // Note: EmailCampaign requires projectId. This should be passed as parameter in production.
  const campaign = await prisma.emailCampaign.create({
    data: {
      projectId: '', // TODO: Pass projectId as parameter
      name: data.subject,
      emailProvider: 'RESEND',
      subject: data.subject,
      content: data.content,
      scheduledAt: new Date(),
      status: 'SCHEDULED',
      settings: {
        activities: data.activities,
      },
    },
  });

  const newsletter: Newsletter = {
    id: campaign.id,
    subject: campaign.subject,
    content: campaign.content || '',
    htmlContent: '',
    status: campaign.status.toLowerCase() as Newsletter['status'],
    scheduledFor: campaign.scheduledAt || new Date(),
    activities: (campaign.settings as any)?.activities || data.activities,
  };

  return newsletter;
}

// Send newsletter to subscribers
async function sendNewsletterToSubscribers(
  newsletter: Newsletter,
  subscribers: Subscriber[],
  content: { highlights: string[]; details: string; whatsNext: string }
): Promise<void> {
  // Batch send to avoid rate limits
  const batchSize = 100;

  for (let i = 0; i < subscribers.length; i += batchSize) {
    const batch = subscribers.slice(i, i + batchSize);

    await Promise.all(
      batch.map(async (subscriber) => {
        const unsubscribeUrl = `${process.env.NEXT_PUBLIC_APP_URL}/newsletter/unsubscribe?token=${generateUnsubscribeToken(subscriber.id)}`;

        try {
          await resend.emails.send({
            from: process.env.EMAIL_FROM!,
            to: subscriber.email,
            subject: newsletter.subject,
            react: NewsletterEmail({
              subject: newsletter.subject,
              previewText: newsletter.subject,
              content,
              unsubscribeUrl,
            }),
          });
        } catch (error) {
          console.error(`Failed to send to ${subscriber.email}:`, error);
        }
      })
    );

    // Rate limiting
    if (i + batchSize < subscribers.length) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

// Update newsletter status
async function updateNewsletterStatus(
  id: string,
  status: Newsletter['status'],
  recipientCount?: number
): Promise<void> {
  await prisma.emailCampaign.update({
    where: { id },
    data: {
      status: status.toUpperCase() as 'DRAFT' | 'SCHEDULED' | 'SENT' | 'FAILED',
      sentAt: status === 'sent' ? new Date() : undefined,
      settings: {
        recipientCount: recipientCount || 0,
      },
    },
  });
}

// Generate unsubscribe token
function generateUnsubscribeToken(subscriberId: string): string {
  // In production, use proper token generation with signing
  return Buffer.from(`${subscriberId}:${Date.now()}`).toString('base64');
}

// Subscribe to newsletter
export async function subscribeToNewsletter(email: string, name?: string): Promise<Subscriber> {
  const subscribedAt = new Date();

  // Remove from unsubscribe list if exists
  await prisma.emailUnsubscribe.deleteMany({
    where: { email },
  });

  const subscriber: Subscriber = {
    id: email, // Using email as ID
    email,
    name,
    subscribedAt,
    status: 'active',
    preferences: {
      frequency: 'weekly',
      topics: [],
    },
  };

  // Note: We don't create EmailRecipient here - it's created when emails are sent
  // Instead, store subscription preferences in KV for now
  await kv.set(`subscriber:${email}`, {
    name,
    subscribedAt: subscribedAt.toISOString(),
    preferences: subscriber.preferences,
  });

  // Send welcome email
  await sendWelcomeEmail(subscriber);

  return subscriber;
}

// Send welcome email
async function sendWelcomeEmail(subscriber: Subscriber): Promise<void> {
  try {
    await resend.emails.send({
      from: process.env.EMAIL_FROM!,
      to: subscriber.email,
      subject: 'Welcome to Dev Updates!',
      html: `
        <h1>Welcome to Dev Updates!</h1>
        <p>Hi ${subscriber.name || 'there'},</p>
        <p>You're now subscribed to our weekly development newsletter.</p>
        <p>Every week, you'll receive:</p>
        <ul>
          <li>Highlights of our development progress</li>
          <li>Technical insights from our codebase</li>
          <li>Upcoming features and improvements</li>
        </ul>
        <p>Thanks for subscribing!</p>
      `,
    });
  } catch (error) {
    console.error('Failed to send welcome email:', error);
  }
}

// Unsubscribe from newsletter
export async function unsubscribeFromNewsletter(token: string): Promise<void> {
  try {
    // Decode token (in production, verify signature)
    const decoded = Buffer.from(token, 'base64').toString();
    const [subscriberId] = decoded.split(':');

    // Get subscriber email from KV or use subscriberId as email
    const subscriber = await kv.get<{ email?: string }>(`subscriber:${subscriberId}`);
    const email = subscriber?.email || subscriberId;

    // Add to unsubscribe list
    await prisma.emailUnsubscribe.create({
      data: {
        email,
        reason: 'User requested unsubscribe',
      },
    });

    // Remove from KV
    await kv.del(`subscriber:${subscriberId}`);
  } catch (error) {
    console.error('Failed to unsubscribe:', error);
    throw error;
  }
}