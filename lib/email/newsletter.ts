import { Resend } from 'resend';
import { sql } from '@vercel/postgres';
import { kv } from '@vercel/kv';
import { generateNewsletter } from '@/lib/ai/content-generator';
import { getRecentActivities } from '@/lib/github/webhook-handler';
import type { Newsletter, Subscriber, GitHubActivity } from '@/lib/types';
import NewsletterEmail from '@/emails/newsletter-template';

const resend = new Resend(process.env.RESEND_API_KEY);

// Generate and send weekly newsletter
export async function generateAndSendNewsletter(): Promise<void> {
  try {
    console.log('Starting newsletter generation...');

    // Get activities from the past week
    const activities = await getWeeklyActivities();

    if (activities.length === 0) {
      console.log('No activities this week, skipping newsletter');
      return;
    }

    // Generate newsletter content
    const content = await generateNewsletter(activities);

    // Parse content into newsletter format
    const newsletterContent = parseNewsletterContent(content.content);

    // Get active subscribers
    const subscribers = await getActiveSubscribers();

    if (subscribers.length === 0) {
      console.log('No active subscribers');
      return;
    }

    // Create newsletter record
    const newsletter = await createNewsletterRecord({
      subject: content.title,
      content: content.content,
      htmlContent: '', // Will be generated by React Email
      status: 'scheduled',
      activities,
    });

    // Send to all subscribers
    await sendNewsletterToSubscribers(newsletter, subscribers, newsletterContent);

    // Update newsletter status
    await updateNewsletterStatus(newsletter.id, 'sent', subscribers.length);

    console.log(`Newsletter sent to ${subscribers.length} subscribers`);
  } catch (error) {
    console.error('Failed to generate and send newsletter:', error);
    throw error;
  }
}

// Get activities from the past week
async function getWeeklyActivities(): Promise<GitHubActivity[]> {
  const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;

  // Get all recent activities
  const activities = await getRecentActivities(100);

  // Filter to past week only
  return activities.filter(activity =>
    new Date(activity.timestamp).getTime() > oneWeekAgo
  );
}

// Parse newsletter content into structured format
function parseNewsletterContent(content: string): {
  highlights: string[];
  details: string;
  whatsNext: string;
} {
  // Simple parsing - in production, use more sophisticated parsing
  const sections = content.split(/##\s+/);

  const highlights: string[] = [];
  let details = '';
  let whatsNext = '';

  sections.forEach(section => {
    if (section.toLowerCase().includes('highlight')) {
      // Extract bullet points
      const bullets = section.match(/[-*]\s+(.+)/g) || [];
      highlights.push(...bullets.map(b => b.replace(/[-*]\s+/, '')));
    } else if (section.toLowerCase().includes('detail')) {
      details = section.replace(/.*\n/, '').trim();
    } else if (section.toLowerCase().includes('next')) {
      whatsNext = section.replace(/.*\n/, '').trim();
    }
  });

  // Fallback if parsing fails
  if (highlights.length === 0) {
    highlights.push('Weekly development updates');
  }
  if (!details) {
    details = content.substring(0, 500);
  }
  if (!whatsNext) {
    whatsNext = 'More updates coming next week!';
  }

  return { highlights, details, whatsNext };
}

// Get active subscribers
async function getActiveSubscribers(): Promise<Subscriber[]> {
  try {
    const { rows } = await sql<Subscriber>`
      SELECT * FROM subscribers
      WHERE status = 'active'
      AND (preferences->>'frequency' = 'weekly' OR preferences->>'frequency' IS NULL)
    `;

    return rows;
  } catch (error) {
    console.error('Failed to get subscribers:', error);
    return [];
  }
}

// Create newsletter record
async function createNewsletterRecord(
  data: Omit<Newsletter, 'id' | 'sentAt' | 'recipientCount' | 'openRate' | 'clickRate'>
): Promise<Newsletter> {
  const id = `newsletter_${Date.now()}`;

  const newsletter: Newsletter = {
    id,
    ...data,
    scheduledFor: new Date(),
  };

  await sql`
    INSERT INTO newsletters (
      id, subject, content, html_content, status, scheduled_for, activities
    )
    VALUES (
      ${newsletter.id},
      ${newsletter.subject},
      ${newsletter.content},
      ${newsletter.htmlContent},
      ${newsletter.status},
      ${newsletter.scheduledFor},
      ${JSON.stringify(newsletter.activities)}
    )
  `;

  return newsletter;
}

// Send newsletter to subscribers
async function sendNewsletterToSubscribers(
  newsletter: Newsletter,
  subscribers: Subscriber[],
  content: { highlights: string[]; details: string; whatsNext: string }
): Promise<void> {
  // Batch send to avoid rate limits
  const batchSize = 100;

  for (let i = 0; i < subscribers.length; i += batchSize) {
    const batch = subscribers.slice(i, i + batchSize);

    await Promise.all(
      batch.map(async (subscriber) => {
        const unsubscribeUrl = `${process.env.NEXT_PUBLIC_APP_URL}/newsletter/unsubscribe?token=${generateUnsubscribeToken(subscriber.id)}`;

        try {
          await resend.emails.send({
            from: process.env.EMAIL_FROM!,
            to: subscriber.email,
            subject: newsletter.subject,
            react: NewsletterEmail({
              subject: newsletter.subject,
              previewText: newsletter.subject,
              content,
              unsubscribeUrl,
            }),
          });
        } catch (error) {
          console.error(`Failed to send to ${subscriber.email}:`, error);
        }
      })
    );

    // Rate limiting
    if (i + batchSize < subscribers.length) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
}

// Update newsletter status
async function updateNewsletterStatus(
  id: string,
  status: Newsletter['status'],
  recipientCount?: number
): Promise<void> {
  await sql`
    UPDATE newsletters
    SET
      status = ${status},
      sent_at = ${status === 'sent' ? new Date() : null},
      recipient_count = ${recipientCount || 0}
    WHERE id = ${id}
  `;
}

// Generate unsubscribe token
function generateUnsubscribeToken(subscriberId: string): string {
  // In production, use proper token generation with signing
  return Buffer.from(`${subscriberId}:${Date.now()}`).toString('base64');
}

// Subscribe to newsletter
export async function subscribeToNewsletter(email: string, name?: string): Promise<Subscriber> {
  const id = `sub_${Date.now()}`;

  const subscriber: Subscriber = {
    id,
    email,
    name,
    subscribedAt: new Date(),
    status: 'active',
    preferences: {
      frequency: 'weekly',
      topics: [],
    },
  };

  await sql`
    INSERT INTO subscribers (
      id, email, name, subscribed_at, status, preferences
    )
    VALUES (
      ${subscriber.id},
      ${subscriber.email},
      ${subscriber.name},
      ${subscriber.subscribedAt},
      ${subscriber.status},
      ${JSON.stringify(subscriber.preferences)}
    )
    ON CONFLICT (email) DO UPDATE
    SET status = 'active', subscribed_at = ${subscriber.subscribedAt}
  `;

  // Send welcome email
  await sendWelcomeEmail(subscriber);

  return subscriber;
}

// Send welcome email
async function sendWelcomeEmail(subscriber: Subscriber): Promise<void> {
  try {
    await resend.emails.send({
      from: process.env.EMAIL_FROM!,
      to: subscriber.email,
      subject: 'Welcome to Dev Updates!',
      html: `
        <h1>Welcome to Dev Updates!</h1>
        <p>Hi ${subscriber.name || 'there'},</p>
        <p>You're now subscribed to our weekly development newsletter.</p>
        <p>Every week, you'll receive:</p>
        <ul>
          <li>Highlights of our development progress</li>
          <li>Technical insights from our codebase</li>
          <li>Upcoming features and improvements</li>
        </ul>
        <p>Thanks for subscribing!</p>
      `,
    });
  } catch (error) {
    console.error('Failed to send welcome email:', error);
  }
}

// Unsubscribe from newsletter
export async function unsubscribeFromNewsletter(token: string): Promise<void> {
  try {
    // Decode token (in production, verify signature)
    const decoded = Buffer.from(token, 'base64').toString();
    const [subscriberId] = decoded.split(':');

    await sql`
      UPDATE subscribers
      SET
        status = 'unsubscribed',
        unsubscribed_at = ${new Date()}
      WHERE id = ${subscriberId}
    `;
  } catch (error) {
    console.error('Failed to unsubscribe:', error);
    throw error;
  }
}